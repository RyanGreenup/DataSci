#+TITLE: Big Data; 02 Practical - Python Basics 2
:CONFIG:
# #+STARTUP: latexpreview
#+INFOJS_OPT: view:showall toc:3
#+PLOT: title:"Citas" ind:1 deps:(3) type:2d with:histograms set:"yrange [0:]"
#+OPTIONS: tex:t
#+TODO: TODO IN-PROGRESS WAITING DONE
#+CATEGORY: TAD
:HTML:
#+INFOJS_OPT: view:info toc:3
#+HTML_HEAD_EXTRA:      [ State ]: something in this group has been edited but not set.
   line-style when
    # you want that feature
#+CSL_STYLE: /home/ryan/Templates/CSL/nature.csl
:END:
:PYTHON:
#+PROPERTY: header-args:python :session BIGDATAMain :dir ./ :cache yes :eval never-export :exports both :results output
# exports: both (or code or whatever)
# results: table (or output or whatever)
:END:
:SlowDown:
# #+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage{/home/ryan/Dropbox/profiles/Templates/LaTeX/ScreenStyle}
# #+LATEX_HEADER: \twocolumn
# [[/home/ryan/Dropbox/profiles/Templates/LaTeX/ScreenStyl   [ State ]: EDITED, shown value does not take effect until you set or save it.
:END:

* Calculate Data Statistics

** Sum Values
So what we need to do is go through each value and tally it up, it is important
however to return the value and the print it:

#+begin_src python
def mysum(x):
    total = float(0)
    for i in x:
        total = total + float(i)
    return total

value = mysum([1,2,3])
print(value)
#+end_src

#+RESULTS[09854f20420c9d1ea7c46194294b491ba170ef14]:
: 6.0

*** Improvements

We could however improve this by using a =try= / =except= test, in the event
that a non-numerical list is provided:

#+begin_src python
def mysum(x):
    total = float(0)
    for i in x:
        try:
            total = total + float(i)
        except:
            print("The Values of the list must be numeric")
            print("Discarding Value")
    return total

value = mysum([1,2,3, "apple"])
print(value)
#+end_src

#+RESULTS[b0be94d0245bb61ce148093311ba1a95cdad7f76]:
: The Values of the list must be numeric
: 6.0
** Minimum Value

Take the first item of the list as a candidate, for every item in the list, compare it to the candidate, if the next value is bigger that will become the new candidate, finally the candidate will be the maximum value.

Just like above we use a =try= / =except= to prevent issues.

#+begin_src python
def mymax(list_of_vals):
    candidate = list_of_vals[0]  # Unlike R/Mathematica/Julia, python starts from 0.
    for i in list_of_vals:
        try:
            if i > candidate:
                candidate = float(i)
        except:
            print("The list items must be numeric")
            print("Discarding Value")
    return candidate

print(mymax([4, 6, 2, 5, 7, 3, 8, "john", -9]))
#+end_src

#+RESULTS[d9a918a92fd085f0a2930c4f7453b2bff16a27e8]:
: The list items must be numeric
: Discarding Value
: 8.0

** Maximum Value

Same as above, just remember to:

- wrap in =float()= as appropriate
- print the function call.


#+begin_src python
def mymin(thelist):
    candidate = thelist[0]
    for i in thelist:
        try:
            if float(i) > float(candidate):
                candidate = i
        except:
            print("list items must be numeric, discarding value")
    return candidate

value = mymin([1, 5, 3, "apple", 8, 2, -9])
print(value)
#+end_src

#+RESULTS[8f2d0f5538f058b50f2dd62a00b527447541c598]:
: list items must be numeric, discarding value
: 8

* Vector Norm, Inner Product and Distance
** Piping
The /Toolz/ Module gives something very similar to piping in bash / julia / R
** Using Built ins
#+begin_src python
import math as mt
import copy

## because python counts from 0 indexing is confusing,
## the count will come back as 4, but the indexes will be 0, 1, 2 and 3.

def getNorm(x):
    total = 0
    for i in range(len(x)):
        total=x[i-1]**2+total
    return mt.sqrt(total)

print(len([1,2,3,4]))


xvec = [0, 1, 2, 3, 4]
yvec = [4, 3, 2, 1, 0]

norm = getNorm(xvec);            print(norm)
#+end_src

#+RESULTS[66db8060093765fd412603b4e7791db6ec095b8b]:
: 4
: 5.477225575051661

** Inner Product
#+begin_src python

def getInnerProd(x, y):
    z = copy.deepcopy(x)    ## Careful, you need to copy, not just assign
    if len(x) == len(y):
        for i in range(len(x)):
            z[i] = x[i]*y[i]
        return sum(z)
    else:
        print("The vectors must have the same dimension")
xvec = [0, 1, 2, 3, 4]
yvec = [4, 3, 2, 1, 0]

norm = getNorm(xvec);            print(norm)
norm = getNorm(yvec);            print(norm)
prod = getInnerProd(xvec, yvec); print(prod)
#+end_src

#+RESULTS[4a669b1d5cd377a0e367e900faeb93be24e17688]:
: 5.477225575051661
: 5.477225575051661
: 10
: 6.324555320336759

** Distance
#+begin_src python

def getDist(x, y):
    if len(x) == len(y):
        z = mt.sqrt(getNorm(x)**2 + getNorm(y)**2 - 2 * getInnerProd(x, y))
        return z
    else:
        print("The vectors must have the same dimension")


xvec = [0, 1, 2, 3, 4]
yvec = [4, 3, 2, 1, 0]

norm = getNorm(xvec);            print(norm)
norm = getNorm(yvec);            print(norm)
prod = getInnerProd(xvec, yvec); print(prod)
dist = getDist(xvec, yvec);      print(dist)

#+end_src

* Vote Counting

#+begin_src python
votes = "N , Y, Y,N,n , N , N  N ,n ,y, n,N,Y, y,Y,N , N , n ,y,N"
def countVotes(ballot):
    ballot = ballot.replace(",","").replace(" ", "").upper()
    neg_ballots = ballot.count("N")
    pos_ballots = ballot.count("Y")

    # Could also have used a loop
    print(str(pos_ballots) + " Yes votes and " + str(neg_ballots) + " No votes")

countVotes(votes)
votes = ",,yyyyn,,y,y,nn,y,,nn,y"
#+end_src

#+RESULTS[769d81700bb0fe64c9cfcbe59254d39b16892213]:
: 7 Yes votes and 13 No votes

* Word Capitaliser
#+begin_src python
def capitalise(sentence):
    ## Split the words into a list
    wordsList = sentence.split()
    ## These are escape words
    EscWords = ["am", "a", "an", "the", "am", "is", "are", "and", "of", "in", "on", "with", "from", "to"]
    ## The number of words starting from 0
    for i in range(len(wordsList)-1):
        ## if not in the escape words
        if i not in EscWords:
            ## replace the ith word for a capitalized one
            wordsList[i] = wordsList[i].capitalize()
    ## Take a space and use it to join the list together
    sentence_Capitalized = " ".join(wordsList)
    ## Print the output
    print(sentence_Capitalized)
    return sentence_Capitalized

capitalise("The quick brown fox jumped over the lazy dogs")
#+end_src

#+RESULTS[81a994cb77b1d20a90230bafe39bf47128775771]:
: The Quick Brown Fox Jumped Over The Lazy dogs

* TODO Parse File

** Set up the Text File

Take the following text:
#+begin_quote
Unit ID, unit name, course name
301046, Big Data, MICT
300581, Programming Techniques, BICT
300144, Object Oriented Analysis, BICT
300103, Data Structure, BCS
300147, Object Oriented Programming, BCS
300569, Computer Security, BIS
301044, Data Science, MICT
300582, Technologies for Web Applications, BICT
#+end_quote

Let's write it to a file:

#+begin_src bash
pwd
ls
#+end_src

#+RESULTS:
| /home/ryan/DataSci/BigData/Practicals |
| 02_Practical_2-Python_Basics-II.html  |
| 02_Practical_2-Python_Basics-II.org   |

#+begin_src python
scemunits = """
Unit ID, unit name, course name
301046, Big Data, MICT
300581, Programming Techniques, BICT
300144, Object Oriented Analysis, BICT
300103, Data Structure, BCS
300147, Object Oriented Programming, BCS
300569, Computer Security, BIS
301044, Data Science, MICT
300582, Technologies for Web Applications, BICT
"""



f = open('scemunits.txt', "w")

for i in scemunits.split('\n'):
    f.writelines(i+'\n')

f.close()
#+end_src

#+RESULTS[2da7d03a76835d57d4add6b9b866ac95e02d533a]:

Observe that:

1. The ~"""~ are necessary for new line strings
2. The ~open(file, w)~ will write over any pre-existing file (like ~>~ in ~bash~)
   1. usint ~open(file,a)~ would append to a file (like ~>>~ in ~bash~)
3. Nothing is written to disk until apter ~f.close()~, that's when the changes go from memory to disk.


* TODO Parse Dictionary
* TODO grep
* TODO Top 10 Words
