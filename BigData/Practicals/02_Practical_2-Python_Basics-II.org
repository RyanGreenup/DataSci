#+TITLE: Big Data; 02 Practical - Python Basics 2
:CONFIG:
# #+STARTUP: latexpreview
#+INFOJS_OPT: view:showall toc:3
#+PLOT: title:"Citas" ind:1 deps:(3) type:2d with:histograms set:"yrange [0:]"
#+OPTIONS: tex:t
#+TODO: TODO IN-PROGRESS WAITING DONE
#+CATEGORY: TAD
:HTML:
#+INFOJS_OPT: view:info toc:3
#+HTML_HEAD_EXTRA:      [ State ]: something in this group has been edited but not set.
   line-style when
    # you want that feature
#+CSL_STYLE: /home/ryan/Templates/CSL/nature.csl
:END:
:PYTHON:
#+PROPERTY: header-args:python :session BIGDATAMain :dir ./ :cache yes :eval never-export :exports both :results output
# exports: both (or code or whatever)
# results: table (or output or whatever)
:END:
:SlowDown:
# #+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage{/home/ryan/Dropbox/profiles/Templates/LaTeX/ScreenStyle}
# #+LATEX_HEADER: \twocolumn
# [[/home/ryan/Dropbox/profiles/Templates/LaTeX/ScreenStyl   [ State ]: EDITED, shown value does not take effect until you set or save it.
:END:

* Calculate Data Statistics

** Sum Values
So what we need to do is go through each value and tally it up, it is important
however to return the value and the print it:

#+begin_src python
def mysum(x):
    total = float(0)
    for i in x:
        total = total + float(i)
    return total

value = mysum([1,2,3])
print(value)
#+end_src

#+RESULTS[09854f20420c9d1ea7c46194294b491ba170ef14]:
: 6.0

*** Improvements

We could however improve this by using a =try= / =except= test, in the event
that a non-numerical list is provided:

#+begin_src python
def mysum(x):
    total = float(0)
    for i in x:
        try:
            total = total + float(i)
        except:
            print("The Values of the list must be numeric")
            print("Discarding Value")
    return total

value = mysum([1,2,3, "apple"])
print(value)
#+end_src

#+RESULTS[b0be94d0245bb61ce148093311ba1a95cdad7f76]:
: The Values of the list must be numeric
: 6.0
** Minimum Value

Take the first item of the list as a candidate, for every item in the list, compare it to the candidate, if the next value is bigger that will become the new candidate, finally the candidate will be the maximum value.

Just like above we use a =try= / =except= to prevent issues.

#+begin_src python
def mymax(list_of_vals):
    candidate = list_of_vals[0]  # Unlike R/Mathematica/Julia, python starts from 0.
    for i in list_of_vals:
        try:
            if i > candidate:
                candidate = float(i)
        except:
            print("The list items must be numeric")
            print("Discarding Value")
    return candidate

print(mymax([4, 6, 2, 5, 7, 3, 8, "john", -9]))
#+end_src

#+RESULTS[d9a918a92fd085f0a2930c4f7453b2bff16a27e8]:
: The list items must be numeric
: Discarding Value
: 8.0

** Maximum Value

Same as above, just remember to:

- wrap in =float()= as appropriate
- print the function call.


#+begin_src python
def mymin(thelist):
    candidate = thelist[0]
    for i in thelist:
        try:
            if float(i) > float(candidate):
                candidate = i
        except:
            print("list items must be numeric, discarding value")
    return candidate

value = mymin([1, 5, 3, "apple", 8, 2, -9])
print(value)
#+end_src

#+RESULTS[8f2d0f5538f058b50f2dd62a00b527447541c598]:
: list items must be numeric, discarding value
: 8


* Vector Norm, Inner Product and Distance
** Piping
The /Toolz/ Module gives something very similar to piping in bash / julia / R
** Using Built ins
#+begin_src python
import math as mt
import copy

## because python counts from 0 indexing is confusing,
## the count will come back as 4, but the indexes will be 0, 1, 2 and 3.

def getNorm(x):
    total = 0
    for i in range(len(x)):
        total=x[i-1]**2+total
    return mt.sqrt(total)

print(len([1,2,3,4]))


xvec = [0, 1, 2, 3, 4]
yvec = [4, 3, 2, 1, 0]

norm = getNorm(xvec);            print(norm)
#+end_src

#+RESULTS[66db8060093765fd412603b4e7791db6ec095b8b]:
: 4
: 5.477225575051661

** Inner Product
#+begin_src python

def getInnerProd(x, y):
    z = copy.deepcopy(x)    ## Careful, you need to copy, not just assign
    if len(x) == len(y):
        for i in range(len(x)):
            z[i] = x[i]*y[i]
        return sum(z)
    else:
        print("The vectors must have the same dimension")
xvec = [0, 1, 2, 3, 4]
yvec = [4, 3, 2, 1, 0]

norm = getNorm(xvec);            print(norm)
norm = getNorm(yvec);            print(norm)
prod = getInnerProd(xvec, yvec); print(prod)
#+end_src

#+RESULTS[4a669b1d5cd377a0e367e900faeb93be24e17688]:
: 5.477225575051661
: 5.477225575051661
: 10
: 6.324555320336759

** Distance
#+begin_src python

def getDist(x, y):
    if len(x) == len(y):
        z = mt.sqrt(getNorm(x)**2 + getNorm(y)**2 - 2 * getInnerProd(x, y))
        return z
    else:
        print("The vectors must have the same dimension")


xvec = [0, 1, 2, 3, 4]
yvec = [4, 3, 2, 1, 0]

norm = getNorm(xvec);            print(norm)
norm = getNorm(yvec);            print(norm)
prod = getInnerProd(xvec, yvec); print(prod)
dist = getDist(xvec, yvec);      print(dist)

#+end_src

* TODO Vote Counting

* TODO Word Capitaliser
* TODO Parse File
* TODO Parse Dictionary
* TODO grep
* TODO Top 10 Words
